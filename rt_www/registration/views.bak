from django.template import Context, loader, RequestContext
from django.shortcuts import render_to_response
from rt_www.index.models import Schedule
from rt_www.index.views import get_current_season
from rt_www.swimmers.models import Swimmer, State, GENDERS
from rt_www.auth.models import User
from rt_www.registration.models import Payment, PayPalLogMsg, Period, Plan, Registration, NOT_PAID, PAID, PENDING, CANCELLED, ENDED
from rt_www.mailinglist.models import MailingList
from datetime import datetime, date
from django.http import HttpResponse
from django.conf import settings #PPGATEWAY, PPSEND, AUTHTOKEN, BUSINESS_EMAIL
import re, math, simplejson, urllib2, urllib, calendar

def index(request):
	new_data = errors = {}
	return render_to_response('registration/index.html', {'reg_period':get_current_season(), 'errors':errors }, 
		context_instance=RequestContext(request))

def getstates(request):	
	return HttpResponse(simplejson.dumps([ { 'code':s.code, 'id':s.id } for s in State.objects.all() ]), 
		mimetype='application/javascript') 

def getplans(request):

	plans = Plan.objects.filter(reg_period__period_start__lte=datetime.now(), 
			reg_period__period_end__gte=datetime.now())
	
	planhash = []
	for p in plans:
		name = ' '.join([ n.capitalize() for n in (p.name).split(' ') ])
		planhash.append({'name':name + ' - $ %0.2lf' % p.base_amount, 'value':p.id})
	
	return HttpResponse(simplejson.dumps(planhash), mimetype='application/javascript')

def lookup(request):
	new_data = errors = {}
	userhash = {'error':[]}
	if request.GET:
		new_data = request.GET.copy()
		email = new_data['email']
		dob = new_data['dob']
		
		try:
			dob = date(int(dob[4:8]), int(dob[0:2]), int(dob[2:4]))
		except ValueError: #Catches invalid dates
			userhash['error'].append('Invalid date. Check that the date of birth and email are correct.')
			dob = None
		
		if email and dob:
				
			swimmer = None
			try:
				swimmer = Swimmer.objects.get(user__email__exact=email, date_of_birth__exact=dob)
			except Swimmer.DoesNotExist:
				userhash['error'].append('Swimmer is not in the database. Check that the date of birth and email are correct.')
			if swimmer != None:
				usms = ''
				usms_reg = re.compile('^\w{2}(\d{1})')
				m = usms_reg.search(swimmer.usms_code)
				if m:
					usms_year = m.group(1)
					current_year = str(datetime.now().year)[-1]
					next_year = str(datetime.now().year + 1)[-1]
					if usms_year == next_year  and datetime.now().month == 12 and datetime.now().day >= 1:
						usms = swimmer.usms_code
					elif usms_year == current_year and datetime.now().month < 12:
						usms = swimmer.usms_code
				swimmer_dict = { 'firstname':swimmer.user.first_name, 'lastname':swimmer.user.last_name, \
						'email':swimmer.user.email, 'address':swimmer.street, 'address2':swimmer.street2, \
						'usms':usms, 'city':swimmer.city, 'state':swimmer.state.id, 'zip':swimmer.zipcode, \
						'dob':swimmer.date_of_birth.strftime('%m%d%Y'), 'dayphone':swimmer.day_phone, 
						'evephone':swimmer.evening_phone, 'gender':swimmer.gender,
						'sid':swimmer.id }
				for k, v in swimmer_dict.items():
					userhash[k] = v
		else:
			userhash['error'].append('Email and date of birth are required for lookup.')
	else:
		userhash['error'].append('Swimmer is not in the database. Check that the date of birth and email are correct.')
	
	return HttpResponse(simplejson.dumps(userhash), mimetype='application/javascript')
	
def calc_delay_duration(annual, month_rate):
	""" let's prorate instead of doing this delay mumbo jumbo
	    unless it is after december 15. Then just delay.
	"""
	year, month, day = datetime.now().year, datetime.now().month, datetime.now().day
	plan_hash = {}
	owed_now = 0.0
	duration = 0
	
	"""
	It would be better to get this amount from the plan rather than have it hard coded
	"""
	if annual:
		owed_now = 40.00
	day_discard, month_days = calendar.monthrange(year, month) 
	days_left = month_days - (day - 1)
	day_rate = month_rate / month_days 
	scale = 0.85
	passed_days_value = day * day_rate * scale
	
	prorate = month_rate - (day * day_rate * scale) 
	original_month = month 
	if month < 12 or day <= 15: 
		owed_now += prorate 
	if month == 12 and day > 15:
		month = 1
	duration = 12 - month
	owed_now = '%0.2lf' % owed_now
	if days_left > 0 and duration > 0:
		plan_hash['plan_amount_value'] = owed_now 
		plan_hash['plan_amount_name'] = 'a1'
		plan_hash['plan_period_name'] = 'p1'
		plan_hash['plan_period_value'] = days_left
		plan_hash['plan_period_units_name'] = 't1'
		plan_hash['plan_period_units_value'] = 'D'
	if days_left == 0 or (original_month == 12 and month == 1): 
		duration += 1

	return plan_hash, duration, days_left, owed_now 

def get_annual_plan():
	current_year = datetime.now().year
	period_start = date(year=current_year, month=1, day=1)
	period_end = date(year=current_year, month=12, day=31)
		
	if datetime.now().month == 12 and datetime.now().day > 5:
		period_start = date(year=current_year,month=11,day=1) 
		current_year += 1
		"""period_start = date(year=current_year, month=1, day=1)
		"""
		period_end = date(year=current_year, month=12, day=31)
			
	try:
		current_period = Period.objects.get(period_start__exact=period_start, period_end__exact=period_end)
	except Period.DoesNotExist:
		log('period doesnt exist')
		current_period = Period(period_start=period_start, period_end=period_end)
		current_period.save()
			
	try:
		annual_plan = Plan.objects.get(name__exact='%d Annual Membership' % current_year)
	except Plan.DoesNotExist:
		log('plan doesnt exist')
		annual_plan = Plan(name='%d Annual Membership' % current_year, base_amount=40.00, reg_period=current_period)
		annual_plan.save()
	return annual_plan	
		
def complete(request):
	new_data = errors = {}
	if request.GET:
		new_data = request.GET.copy()
		swimmer, user, state, day_phone, evening_phone, street2 = None, None, None, None, None, None
		email, usms_code = new_data['email'], new_data['usms']
		first_name, last_name = new_data['firstname'], new_data['lastname']
		street, city = new_data['address'], new_data['city']
		state_id = new_data['state']
		zipcode, gender, dob = new_data['zip'], new_data['gender'], new_data['dob']
		
		try:
			state = State.objects.get(pk=state_id)
		except State.DoesNotExist:
			state = State.objects.get(pk=2)
			
		try:
			day_phone, evening_phone, street2 = new_data['dayphone'], new_data['evephone'], new_data['address2']
		except:
			pass
		owed = new_data['owed']
		date_of_birth = date( year=int(dob.split('-')[0]), 
			month=int(dob.split('-')[1]), day=int(dob.split('-')[2]))
		plan_ids = []
		plan_list = []

		for i in range(10):
			try:
				plan_ids.append(new_data['plan%d' % i])
			except KeyError:
				log('Plan not found in registration vars')
				break

		for plan_id in plan_ids:
			try:
				plan_list.append(Plan.objects.get(pk=plan_id ))
			except Plan.DoesNotExist:
				continue
			
		try:
			""" let's try looking up the swimmer first by email
			    the user lookup by first and last name  will fail if 
			    someone gets married and changes their last name (for example)
			    but doesn't change their email address
			"""
			user = User.objects.get(email__exact=email)
			user.save()
		except User.DoesNotExist:
			user = User(username=email, email=email, password='')
			user.is_staff, user.is_superuser, user.username, user.email = False, False, email, email
		
		user.first_name, user.last_name,  = first_name, last_name
		user.is_active = True
		user.save()
		
		try:
			swimmer = Swimmer.objects.get(user__id__exact=user.id)
		except Swimmer.DoesNotExist:
			swimmer = Swimmer(user=user, state=state)
		
		swimmer.user, swimmer.street = user, street
		swimmer.city, swimmer.state, swimmer.zipcode = city, state, zipcode
		swimmer.usms_code, swimmer.date_of_birth = usms_code, date_of_birth
		if day_phone:
			swimmer.day_phone = day_phone
		if evening_phone:
			swimmer.evening_phone = evening_phone
		if street2:
			swimmer.street2 = street2
		swimmer.gender = gender

		swimmer.save()
		""" At this point we check to see if the plan sent is priced at 0 if it is then we save 
		the registration and send them to the confirm page
		"""
		if len(plan_list) == 1 and int(plan_list[0].base_amount) == 0:
			plan = plan_list[0]
			r = None
			try:
				r = Registration.objects.get(swimmer__id__exact=swimmer.id, plan__id__exact=plan.id,
					plan__reg_period__period_start__lte=datetime.now() ,
					plan__reg_period__period_end__gte=datetime.now())
			except Registration.DoesNotExist:
				r = Registration(registration_date=datetime.now(), swimmer=swimmer, plan=plan)

			r.registration_status = PAID
			r.save()
			
			p = None
			try:				
				p = Payment.objects.get(swimmer__id__exact=swimmer.id, 
					plan__id__exact=plan.id, registration__id__exact=r.id)
					
			except Payment.DoesNotExist:
				p = Payment(paypal_trans_id='nopaypal', 
					amount_paid=0.00, swimmer=swimmer, paid_date=datetime.now(),
					plan_id=plan.id, registration_id=r.id )	
			p.save()
			
			""" And finally we sign people up into any mandatory mailing lists """

			mailinglists = MailingList.objects.filter(ismandatory__exact=True)
			swimmer.mailinglist_set.clear()
			swimmer.save()
			for mailinglist in mailinglists:
				swimmer.mailinglist_set.add(mailinglist)
			swimmer.save()	

			return render_to_response('registration/confirm.html', 
						{'payment_gross':'0.00', 'payment_date':datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
						 'payer_email':user.email, 'first_name':user.first_name, 
						 'last_name':user.last_name, 'mc_gross':'0.00', 'payment_type':plan.name
						}, context_instance=RequestContext(request))
	
		annual_plan, contains_annual = get_annual_plan(), False
		cmd = '_cart'
		for plan in plan_list:
			""" If the user already has a registration for this plan in this period
			    the rules for when to create a new one are complicated
			    1) Only one annual registration should exist per swimmer per year
			    2) Never create a new unlimited registration. If the old one is CANCELLED or ENDED, set it to NOT_PAID
			    3) Create a new swimpass registration if the old one has been PAID
			"""
			r = Registration.objects.filter(swimmer__id__exact=swimmer.id, plan__id__exact=plan.id,
				plan__reg_period__period_start__lte=datetime.now() ,
				plan__reg_period__period_end__gte=datetime.now())

			if len(r) > 0:
				if plan.id == annual_plan.id:
					for reg in r:
						reg.registration_date = datetime.now()
						reg.save()
				elif plan.isrecurring:
					found = False
					for reg in r:
						if reg.registration_status == CANCELLED or reg.registration_status == ENDED:
							reg.registration_status = NOT_PAID
						found = True
						reg.registration_date = datetime.now()
						reg.save()
					if not found:
						reg = Registration(registration_date = datetime.now(),
							swimmer=swimmer, plan=plan, registration_status=NOT_PAID)
						reg.save()
				else:
					found = False
					for reg in r:
						if reg.registration_status == NOT_PAID:
							found = True
							reg.registration_date = datetime.now()
							reg.save()
					if not found:
						reg = Registration(registration_date = datetime.now(),
							swimmer = swimmer, plan=plan, registration_status=NOT_PAID)
						reg.save() 
			else:
				reg = Registration(registration_date=datetime.now(), 
					swimmer=swimmer, plan=plan, registration_status=NOT_PAID)
				reg.save()
			if plan.isrecurring:
				cmd = '_xclick-subscriptions'
			if plan.id == annual_plan.id:
				contains_annual = True
		""" Time to build out the paypal crunk
		    If we can't find an Annual Plan we are screwed
		"""

		
		delay, annual_flag = 0, 0
		plan_hash, double, count, payname, plan_set, duration = {}, {}, 1, '', [], 0
		custom = '%d' % swimmer.id
		for p in plan_list:
			plan_amount = float(p.base_amount)				
			if p.id == annual_plan.id:
				annual_flag = 1
			if cmd == '_cart':
				plan_hash['plan_name'] = 'item_name_%d' % count
				plan_hash['plan_name_value'] = p.description 
				plan_hash['plan_number_name'] = 'item_number_%d' % count
				plan_hash['plan_number_value'] = '%d' % p.id 
				plan_hash['plan_cart_amount_name'] = 'amount_%d' % count
				plan_hash['plan_cart_amount_value'] = plan_amount
				plan_hash['plan_quantity_name'] = 'quantity_%d' % count;
				plan_hash['plan_quantity_value'] = '1'
				
			else: 
				if p.id == annual_plan.id:
					payname += p.description
					custom += '|%d' % p.id
					continue	

				plan_hash, duration, delay, owed_now =  calc_delay_duration(contains_annual, plan_amount)
				"""
				If we're only paying for one month plus part of another
				or less then we should use a cart payment
				"""
				if duration <= 1:
					cmd = '_cart'
					plan_hash['plan_name'] = 'item_name_%d' % count
					month = datetime.now().month
					month_name = calendar.month_name[month] 
					if contains_annual:
						plan_hash['plan_name_value'] = 'Annual Fee plus '+ month_name + ' prorated ' + p.description

					else:
						plan_hash['plan_name_value'] = month_name + ' prorated ' + p.description 
					plan_hash['plan_number_name'] = 'item_number_%d' % count
					plan_hash['plan_number_value'] = '%d' % p.id 
					plan_hash['plan_cart_amount_name'] = 'amount_%d' % count
					plan_hash['plan_cart_amount_value'] = owed_now 
					plan_hash['plan_quantity_name'] = 'quantity_%d' % count
					plan_hash['plan_quantity_value'] = 1
					if duration == 1:
						month += 1 
						if month > 12:
							month = 1
						next_month = calendar.month_name[month]
						plan_set.append(plan_hash)
						plan_hash = {}
						count += 1
						plan_hash['plan_name'] = 'item_name_%d' % count
						plan_hash['plan_name_value'] = next_month + ' ' + p.description  
						plan_hash['plan_number_name'] = 'item_number_%d' % count
						plan_hash['plan_number_value'] = '%d' % p.id 
						plan_hash['plan_cart_amount_name'] = 'amount_%d' % count
						plan_hash['plan_cart_amount_value'] = plan_amount
						plan_hash['plan_quantity_name'] = 'quantity_%d' % count
						plan_hash['plan_quantity_value'] = 1 
						
				else: 
					plan_set.append(plan_hash)
					plan_hash = {}
					count+= 1
					plan_hash['plan_amount_name'] = 'a3'
					plan_hash['plan_amount_value'] = plan_amount
					plan_hash['plan_period_name'] = 'p3'
					plan_hash['plan_period_units_name'] = 't3'
					plan_hash['plan_period_value'] = 1 
					plan_hash['plan_period_units_value'] = 'M'
			
			"""
			if delay == 0 and (not contains_annual) and cmd != '_cart':
				double['plan_amount_name'] = 'a1'
				double['plan_period_name'] = 'p1'
				double['plan_period_units_name'] = 't1'
				# charging two months!!
				double['plan_amount_value'] = owed
				double['plan_period_value'] = '1'
				double['plan_period_units_value'] = 'M'
			"""
		
			if len(plan_list) > 1 and payname != '' : 
				payname += ' and '
			payname += p.description
			custom += '|%d' % p.id

			if len(double.keys()) > 0:
				count += 1
				plan_set.append(double)
				double = {}

			plan_set.append(plan_hash)
			plan_hash = {}
			count += 1
		""" test business """
		"""business = 'bogus@fakeredtide.com' """
		""" At this point we have the various things for a POST to paypal """
		global_hash = { 'cmd':cmd, 'custom':custom, 'item_name':payname, 
			'upload':'1', 'business':settings.BUSINESS_EMAIL, 'no_shipping':'1',
			'no_note':'1', 'image_url':'http://www.redtidenyc.org/media/images/RTlogo.jpg',
			'notify_url':'http://www.redtidenyc.org/cgi-bin/payments.cgi'
		}
		if cmd == '_cart':
			for plan in plan_set:
				global_hash[plan['plan_name']] = plan['plan_name_value']
				global_hash[plan['plan_number_name']] = plan['plan_number_value']
				global_hash[plan['plan_cart_amount_name']] = plan['plan_cart_amount_value']
				global_hash[plan['plan_quantity_name']] = plan['plan_quantity_value']
		else:
			for plan in plan_set:
				global_hash[plan['plan_amount_name']] = plan['plan_amount_value']
				global_hash[plan['plan_period_name']] = plan['plan_period_value']
				global_hash[plan['plan_period_units_name']] = plan['plan_period_units_value']
		global_hash['src'] = '1'
		global_hash['srt'] = '%d' % duration
		global_hash['paypal_link'] = settings.PPGATEWAY
		""" What happens at this point is that we return the hash as a json object to the """
		return HttpResponse(simplejson.dumps(global_hash), mimetype='application/javascript') 
	
	
	return HttpResponse(simplejson.dumps({}), mimetype='application/javascript')

def calcowed(request):
	new_data = {}
	ret_val = { 'plans':[], 'owed':0.0 }
	plan_ids = []
	owed = 0.0
	annual_plan = get_annual_plan()
	if request.GET:
		new_data = request.GET.copy()
		if new_data.has_key('plan') and new_data.has_key('sid') and new_data['plan'] != '':
			pid, sid, swimmer, double, owed = int(new_data['plan']), int(new_data['sid']), None, True, 0
			annual_paid = False
			plan_paid = False
			if sid > 0:
				""" First check if they've already paid for the annual membership
				"""		
				r = Registration.objects.filter(swimmer__id__exact=sid,
					plan__id__exact=annual_plan.id,
					registration_status__in=[PAID,PENDING],
					plan__reg_period__period_start__lte=datetime.now(),
					plan__reg_period__period_end__gte=datetime.now())
				if len(r) > 0:
					annual_paid = True

					""" If we were only trying to register annual, return now.
					"""
					if pid == annual_plan.id:
						plan_ids.append(pid)
						owed = 0.0
						ret_val['owed'] = '%0.2lf' % owed
						ret_val['plans'] = plan_ids
						return HttpResponse(simplejson.dumps(ret_val), mimetype='application/javascript')

				""" If they are trying to buy a recurring package they've 
			    	    already paid for we deal with that
				"""
				r = Registration.objects.filter(swimmer__id__exact=sid, 
					plan__id__exact=pid,
					registration_status__exact=PAID,
					plan__isrecurring__exact=True,
					plan__reg_period__period_start__lte=datetime.now(), 
					plan__reg_period__period_end__gte=datetime.now())
				if len(r) > 0:
					plan_paid = True	

					"""
					If we've already paid for annual return now
					"""
					if annual_paid:
						owed += 0.0
						plan_ids.append(pid) 
						ret_val['plans'] = plan_ids
						ret_val['owed'] = '%0.2lf' % owed 
						return HttpResponse(simplejson.dumps(ret_val), mimetype='application/javascript')	
			""" No more double
			else:	
				double = True
			"""
			pidPlan = Plan.objects.get(pk=pid)
			if not plan_paid: 
				owed += pidPlan.base_amount
			
			if pidPlan.add_annual and ( not annual_paid ):
				plan_ids.append(annual_plan.id)
				owed += int(annual_plan.base_amount)

			""" No more double
			if pidPlan.isrecurring and double:
				owed += plan.base_amount
			"""
			plan_ids.append(pid)	
			ret_val['plans'] = plan_ids
			ret_val['owed'] = '%0.2lf' % owed	
			ret_val['annual'] = annual_plan.id

	return HttpResponse(simplejson.dumps(ret_val), mimetype='application/javascript')	


""" This is to handle what comes from paypal """
"""
	This is a little tricky.  When the paypal request comes in we are supposed to repost it back to paypal
	to validate.  If it vaidates we simply return a 200 OK otherwise we return nothing
"""
def log(mesg):
	msg = PayPalLogMsg(msg=mesg)
	msg.save()


def test_paypal(request):
	return HttpResponse('VERIFIED')

def confirm(request):
	""" secure request to the PayPal server to fetch the transaction info
	"""
	new_data = {}	
	if request.POST:
		new_data = request.POST.copy()
	else:
		new_data = request.GET.copy()
	transaction,message,instructions = '', '', ''
	month,day = datetime.now().month, datetime.now().day
	response_hash = {}
	""" if it's not next year's renewal time and there is no transaction id
	    something went wrong
	"""
	if ((not new_data.has_key('tx')) or new_data['tx'] == '') and month < 12 :
		message = 'Your paypal transaction was cancelled or not completed.'
	elif new_data.has_key('tx') and new_data['tx'] != '': 
		transaction = new_data['tx']
		url = settings.PPSEND
		values = {'tx': transaction, 'cmd':'_notify-synch','at':settings.AUTHTOKEN}
		data = urllib.urlencode(values)
		req = urllib2.Request(url, data)
		resp = None
		try:
			resp = urllib2.urlopen(req)
		except urllib2.URLError, e:
			message = e
			log('request error on transaction synch %s like %s' %(settings.PPSEND, e))
		firstname, lastname, total = '', '', ''
		response_values = resp.readlines()
		message = response_values[0]
		if message == 'SUCCESS\n':
			response_values.remove(message)
			for i in response_values:
				key, value = i.split('=')[0], i.split('=')[1]
				response_hash[key] = urllib.unquote(value)

			if response_hash.has_key('num_cart_items'):
				"""Annual instructions are default"""
				instructions="annual"  

				item_name_1, item_name_2 = '', ''
				if response_hash.has_key('item_name1'):
		 			item_name_1 = response_hash['item_name1']	
				if response_hash.has_key('item_name2'):
		 			item_name_2 = response_hash['item_name2']	
				if re.search('Pass', item_name_1) or re.search('Pass', item_name_2): 
					instructions="pass"
				elif re.search('Monthly', item_name_1) or re.search('Monthly', item_name_2): 
					instructions="monthly"
			else:
				instructions="monthly"
		
		resp.close()
	else:
		message = "Your subscription has been created."
		instructions = "monthly"
		
	response_hash['message'] = message
	response_hash[instructions] = "true" 
			
	return render_to_response('registration/confirm.html', 
		response_hash,
		context_instance=RequestContext(request))

""" Process PayPal Payments """
def process(request):
	new_data = {}
	if request.GET or request.POST:
		
		if request.POST:
			new_data = request.POST.copy()
		else:
			new_data = request.GET.copy()

		new_data['cmd'] = '_notify-validate'
		params = urllib.urlencode(new_data)
		req = urllib2.Request(settings.PPSEND, params)
		req.add_header('Content-type', 'application/x-www-form-urlencoded')
		resp = None
		try:
			resp = urllib2.urlopen(req)
		except urllib2.URLError, e:
			log('request error on %s like %s' %( settings.PPSEND, e))
		if resp.read() == 'VERIFIED': #Good to go.  Save everything down
			log('Verified transaction on the following params %s' % params)
			if ( not new_data.has_key('custom') ) or new_data['custom'] == '':
				log('Ignoring IPN notification of non registration payment')
				return HttpResponse('failed to process')
			txn_id = None
			if new_data.has_key('txn_id'):
				txn_id = new_data['txn_id']
			""" These are just notifications from paypal that someone subscribed. We already know
			this so we can ignore it
			elif new_data.has_key('subscr_id'):
				txn_id = new_data['subscr_id']
			"""
			
			""" If we've already processed this transaction just make a note of it and exit
			"""
			payment = None
			if txn_id:
				try: 
					payment = Payment.objects.filter(paypal_trans_id__exact=txn_id).order_by('paid_date')[0] 
				except:
					pass
			if payment:
				log('Duplicate transaction '  + txn_id + '. skipping.')
				return HttpResponse('Completed')
			
			custom, txn_type = new_data['custom'], new_data['txn_type']
			payment_status = None
			if new_data.has_key('payment_status'):
				payment_status = new_data['payment_status']
			payer_email = new_data['payer_email']
			swimmer_id, pid_arr, swimmer = int(custom.split('|')[0]), [ int(i) for i in custom.split('|')[1:]], None
			plan_hash = {}
			try:
				swimmer = Swimmer.objects.get(pk=swimmer_id)
			except Swimmer.DoesNotExist:
				log('Swimmmer not found - params like %s' % params)

			for pid in pid_arr:
				try:
					p = Plan.objects.get(pk=pid)
					plan_hash['%d' % p.id] = p
				except Plan.DoesNotExist:
					log('Invalid plan id %d' % pid)
			
			if new_data['mc_currency'] != 'USD':
				log('Payment not in Dollars from sid = %d' % swimmer.id)
				return HttpResponse('failed to process') 
			paid, not_paid, pending = False, False, False
			if payment_status == 'Completed' or payment_status == 'Processed':
				paid = True
			if payment_status == 'Failed' or payment_status == 'Denied' or payment_status == 'Refunded' or payment_status == 'Reversed':
				not_paid = True
			if payment_status == 'Pending':
				pending = True
			
			if txn_type == 'cart':
				total_items = int(new_data['num_cart_items'])
				payment_amt = new_data['payment_gross']
				i = 1
				while i <= total_items:
					item_var = 'item_number%d' % i
					if not new_data.has_key(item_var):
						continue
					pid = new_data[item_var]
					try:
						plan = plan_hash[pid]
					except KeyError:
						log('pid %s was not found in paypal custom variables for swimmer %d' %( pid, swimmer_id))
						continue
					amt_paid = float(plan.base_amount)
					leftover = float(payment_amt) - amt_paid
					if int(math.ceil(leftover)) < 0:
						amt_paid = float(payment_amt)
					elif int(math.floor(leftover)) > 0:
						payment_amt = leftover
					
					r = Registration.objects.filter(plan__id__exact=plan.id, 
						swimmer__id__exact=swimmer.id, 
						plan__reg_period__period_start__lte=datetime.now(),
						plan__reg_period__period_end__gte=datetime.now()).exclude(
							registration_status__exact=PAID)
					if len(r) <= 0:
						log('registration not found for pid = %s and swimmerid =%d' 
							%(pid, swimmer.id))
						i += 1
						continue
					if len(r) > 1:
						log('multiple registrations found for pid = %s using the first returned' % pid)
					r = r[0]
					if not_paid: #There was at least a penny unpaid
						r.registration_status = NOT_PAID
					elif paid:
						r.registration_status = PAID
						annual_plan = get_annual_plan()
						if plan.id == annual_plan.id:
							mailinglists = MailingList.objects.filter(ismandatory__exact=True)
							swimmer.mailinglist_set.clear()
							swimmer.save()
							for mailinglist in mailinglists:
								swimmer.mailinglist_set.add(mailinglist)
							swimmer.save()	
					elif pending:
						r.registration_status = PENDING
					r.save()

					payment = Payment(
						paypal_trans_id=txn_id,
						amount_paid=amt_paid,
						swimmer=swimmer,
						paid_date=datetime.now(),
						plan_id=plan.id,
						registration_id=r.id
					)
					payment.save()
					i += 1
			
			elif re.search('subscr', txn_type):
				log('Processing a subscription payment')
				annual_plan = get_annual_plan()
				payment_amt = 0.0
				if new_data.has_key('payment_gross'):
					payment_amt = float(new_data['payment_gross'])
				cancelled = (txn_type == 'subscr_cancel' or txn_type == 'subscr_eot')
				not_paid = ( txn_type == 'subscr_failed' or payment_status == 'Failed' )
				paid = ( txn_type == 'subscr_payment' and (payment_status == 'Completed' or payment_status == 'Processed') )
				pending = ( txn_type == 'subscr_payment' and payment_status == 'Pending' )
				""" 
				   deal with failures or cancellations
				"""
				if txn_type == 'subscr_cancel' or txn_type == 'subscr_failed':
					""" mark each item cancelled EXCEPT for annual if it is paid """
					for pid, plan in plan_hash.iteritems():
						try:
							r = Registration.objects.get(plan__id__exact=plan.id, 
								swimmer__id__exact=swimmer.id,
								plan__reg_period__period_start__lte=datetime.now(),
								plan__reg_period__period_end__gte=datetime.now())
						except Registration.DoesNotExist:
                                                       	log('registration not found for pid = %s and swimmerid =%d'
                                                     	%(pid, swimmer.id))
                                                    	continue
						""" Annual Memberships can't be cancelled if they are already paid
						    If they are pending and the status is FAILED then mark it not paid """
						if plan.id == annual_plan.id:
							if r.registration_status != PAID:
								if not_paid:
									r.registration_status = NOT_PAID
						else:
							if not_paid:
								r.registration_status = NOT_PAID
							elif cancelled:
								r.registration_status = CANCELLED
						r.save()

				"""  
				    now let's handle PAYMENTS 
				"""
				if txn_type == 'subscr_payment':
					""" deal with annual first, if it exists """
					try:
						subscr_annual = plan_hash['%d' % annual_plan.id]
						try:
							r = Registration.objects.get(plan__id__exact=annual_plan.id, 
								swimmer__id__exact=swimmer.id,
								plan__reg_period__period_start__lte=datetime.now(),
								plan__reg_period__period_end__gte=datetime.now())
							""" annual plan payments can't be cancelled 
						    	or reset once they've been paid
							so check if this one is paid before we change the registration status
							"""
							if r.registration_status != PAID:
	
								amt_paid =  float(annual_plan.base_amount)
								leftover = payment_amt - amt_paid
								if int(math.ceil(leftover)) <= 0:
									amt_paid = float(payment_amt)
									payment_amt = 0.0
								elif int(math.floor(leftover)) > 0:
									payment_amt = leftover
								if pending:
									r.registration_status = PENDING
								elif paid:
									r.registration_status = PAID
								r.save()

								""" save payment """
								payment = Payment(
									paypal_trans_id=txn_id,
									amount_paid=amt_paid,
									swimmer=swimmer,
									paid_date=datetime.now(),
									plan_id=annual_plan.id,
									registration_id = r.id
								)
								payment.save()
							""" if they've paid, add them to the mailing lists """
							if r.registration_status == PAID:
								log('adding swimmer to mailinglists')
								mailinglists = MailingList.objects.filter(ismandatory__exact=True)
								swimmer.mailinglist_set.clear()
								for mailinglist in mailinglists:
									swimmer.mailinglist_set.add(mailinglist)
								swimmer.save()	

						except Registration.DoesNotExist:
							log('registration not found for pid = %s and swimmerid =%d' 
								%(annual_plan.id, swimmer.id))
					except KeyError:
						log('annual plan %s was not found in paypal custom variables for swimmer %d' %( annual_plan.id, swimmer_id))
					""" take care of other items in the subscription 
					"""
					for pid, plan in plan_hash.iteritems():
						if plan.id != annual_plan.id:
							try:
								r = Registration.objects.get(plan__id__exact=plan.id, 
									swimmer__id__exact=swimmer.id,
									plan__reg_period__period_start__lte=datetime.now(),
									plan__reg_period__period_end__gte=datetime.now())
							except Registration.DoesNotExist:
                                                        	log('registration not found for pid = %s and swimmerid =%d'
                                                               	%(pid, swimmer.id))
                                                       		continue

							amt_paid =  float(plan.base_amount)

                                               		""" This payment might be less than the plan amount
							if it has been prorated. Record the payment if the amount is over zero.
							"""
							if payment_amt > 0.0:
								leftover = payment_amt - amt_paid
								log('leftover: %s payment_amt: %s amt_paid: %s' % (leftover, payment_amt, amt_paid))

	                                              		if int(math.ceil(leftover)) <= 0:
									amt_paid = float(payment_amt)
									payment_amt = 0.0
                                               			elif int(math.floor(leftover)) > 0:
                                                       			payment_amt = leftover

                                               			if pending:
                                                       			r.registration_status = PENDING
                                              			elif paid:
                                                       			r.registration_status = PAID
                                               			r.save()

                                               			payment = Payment(
                                                       			paypal_trans_id=txn_id,
                                                       			amount_paid=amt_paid,
                                                       			swimmer=swimmer,
                                                       			paid_date=datetime.now(),
                                                       			plan_id=plan.id,
                                                       			registration_id = r.id
                                               			)
                                               			payment.save()

						
			return HttpResponse('Completed')	

		elif resp.read() == 'INVALID':
			log('Couldn\'t validate the transaction, INVALID from paypal on params %s' % params)
		else:
			log('Unverified transaction on the following params %s' % params)
	else: #Error
		log('Received weird request from %s'  % request.META['REMOTE_HOST'])
	return HttpResponse('failed to process')
